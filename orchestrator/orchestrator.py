"""
PHASE 6: Orchestrator - Master Controller
Coordinates all agents and generates final incident report
"""

import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List
import sys

# ===============================
# Fix for module imports
# ===============================
PROJECT_ROOT = Path(__file__).parent.parent
AGENTS_DIR = PROJECT_ROOT / "agents"
sys.path.append(str(AGENTS_DIR))

# Import agents after path fix
from attack_tracer import AttackTracer
from impact_analyst import ImpactAnalyst
from responder_agent import IncidentResponder


class IncidentOrchestrator:
    """Master controller that orchestrates all security agents"""

    def __init__(self):
        self.start_time = None
        self.end_time = None

    def analyze_incident(self, events: List[Dict], save_intermediates: bool = True) -> Dict:
        """Main orchestration method - coordinates all agents"""
        self.start_time = datetime.now()
        print("=" * 70)
        print("ðŸ” SECURITY INCIDENT ANALYSIS SYSTEM")
        print("=" * 70)

        # Stage 1: Attack Detection & Tracing
        print("\n[1/4] Attack Tracer Agent: Analyzing security events...")
        attack_analysis = self._run_attack_tracer(events)

        if save_intermediates:
            self._save_json(attack_analysis, PROJECT_ROOT / 'data/processed/attack_analysis.json')

        if not attack_analysis.get('attack_detected'):
            print("âœ“ No attacks detected. System is secure.")
            return self._generate_clean_report(events)

        print(f"âœ“ Detected {attack_analysis['total_attacks']} attack pattern(s)")

        # Stage 2: Impact Analysis
        print("\n[2/4] Impact Analyst Agent: Assessing business impact...")
        impact_analysis = self._run_impact_analyst(attack_analysis)

        if save_intermediates:
            self._save_json(impact_analysis, PROJECT_ROOT / 'data/processed/impact_analysis.json')

        total_loss = impact_analysis.get('total_estimated_loss_usd', 0)
        print(f"âœ“ Estimated financial impact: ${total_loss:,} USD")

        # Stage 3: Response Planning
        print("\n[3/4] Response Agent: Generating incident response plan...")
        response_plan = self._run_responder(attack_analysis, impact_analysis)

        if save_intermediates:
            self._save_json(response_plan, PROJECT_ROOT / 'data/processed/response_plan.json')

        print(f"âœ“ Generated comprehensive response plan")

        # Stage 4: Generate Final Report
        print("\n[4/4] Orchestrator: Compiling final incident report...")
        final_report = self._generate_final_report(
            events,
            attack_analysis,
            impact_analysis,
            response_plan
        )

        self.end_time = datetime.now()
        analysis_time = (self.end_time - self.start_time).total_seconds()
        final_report['analysis_metadata']['processing_time_seconds'] = round(analysis_time, 2)

        print(f"âœ“ Analysis complete in {analysis_time:.2f} seconds")
        print("=" * 70)

        return final_report

    # --------------------------
    # Agent wrappers
    # --------------------------
    def _run_attack_tracer(self, events: List[Dict]) -> Dict:
        tracer = AttackTracer()
        return tracer.analyze_events(events)

    def _run_impact_analyst(self, attack_analysis: Dict) -> Dict:
        analyst = ImpactAnalyst()
        return analyst.analyze_impact(attack_analysis)

    def _run_responder(self, attack_analysis: Dict, impact_analysis: Dict) -> Dict:
        responder = IncidentResponder()
        return responder.generate_response_plan(attack_analysis, impact_analysis)

    # --------------------------
    # JSON saving helper
    # --------------------------
    def _save_json(self, data: Dict, filepath: Path):
        filepath.parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)

    # --------------------------
    # Report generation helpers
    # --------------------------
    def _generate_final_report(self, events: List[Dict], attack_analysis: Dict,
                                impact_analysis: Dict, response_plan: Dict) -> Dict:
        return {
            "report_id": f"RPT-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            "incident_id": response_plan.get('incident_id', 'N/A'),
            "generated_at": datetime.now().isoformat(),
            "executive_summary": response_plan.get('executive_summary', ''),
            "severity_assessment": {
                "overall_severity": impact_analysis.get('overall_severity', 'Unknown'),
                "severity_justification": "Generated by Orchestrator"
            },
            "attack_intelligence": {
                "total_attacks_detected": attack_analysis.get('total_attacks', 0),
                "attack_breakdown": attack_analysis.get('attack_chains', []),
            },
            "business_impact": {
                "financial_impact_usd": impact_analysis.get('total_estimated_loss_usd', 0),
                "affected_assets": impact_analysis.get('total_affected_assets', 0)
            },
            "incident_response": {
                "immediate_actions": response_plan.get('immediate_actions', []),
                "short_term_actions": response_plan.get('short_term_actions', []),
                "long_term_actions": response_plan.get('long_term_actions', []),
                "estimated_response_time_hours": response_plan.get('estimated_total_response_time_hours', 0),
                "recommended_team_size": response_plan.get('recommended_team_size', 0),
            },
            "analysis_metadata": {
                "total_events_analyzed": len(events),
                "analysis_start_time": self.start_time.isoformat() if self.start_time else None,
                "analysis_end_time": self.end_time.isoformat() if self.end_time else None,
            }
        }

    def _generate_clean_report(self, events: List[Dict]) -> Dict:
        return {
            "report_id": f"RPT-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            "generated_at": datetime.now().isoformat(),
            "status": "No Incidents Detected",
            "executive_summary": "Security analysis completed. No malicious activity detected.",
            "analysis_metadata": {
                "total_events_analyzed": len(events),
                "malicious_events": 0,
                "benign_events": len(events),
                "analysis_complete": True
            }
        }


def main():
    events_file = PROJECT_ROOT / 'data/processed/normalized_events.json'

    try:
        with open(events_file, 'r') as f:
            events = json.load(f)
    except FileNotFoundError:
        print(f"Error: Events file not found at {events_file}")
        print("Please run data normalization first.")
        return

    orchestrator = IncidentOrchestrator()
    final_report = orchestrator.analyze_incident(events, save_intermediates=True)
    report_path = orchestrator._save_json(final_report, PROJECT_ROOT / f'data/reports/incident_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json')
    print(f"\nðŸ“„ Final report saved successfully.")


if __name__ == "__main__":
    main()
